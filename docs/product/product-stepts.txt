-------------------------------------------------------------------------------------------------
// WHEN AN ACCOUNT IS CREATED, CREATE A CORRESPONDING SALEOR CHANNEL.
// LINK TO USER ACCOUNT AND SESSION TO ALWAYS PUSH TO /dashboard/[session.channel].
// A WAREHOUSE CAN BE CREATED ALONGSIDE LINKING IT AND GRABBING WAREHOUSE ID TO THE CUSTOM LAYER.
-------------------------------------------------------------------------------------------------
1. mutation LinkWarehouseToChannel {
  channelUpdate(
    id: "Q2hhbm5lbDoz",
    input: {
      addWarehouses: ["V2FyZWhvdXNlOjVhZmVlYWJjLWNjODMtNDUzNy1hY2IyLWRkNDRhNjJjOTc2Mg=="]
    }
  ) {
    channel { id }
    errors { message }
  }
}
-------------------------------------------------------------------------------------------------
IF EVERYONE HAS TO CREATE A PRODUCT FROM SRATCH EVERYTIME THEY HAVE TO USE OUR PLATFORM. THEN WE HAVE FAILED.
EVERYTIME A PRODUCT IS CREATED, WE ENSURE THAT WE UPDATE OUR CACHE AND MEILISEARCH INSTANCE TO ENABLE/SUPPORT INSTANT SEARCH.
THIS ENSURES WE CAN SEARCH A PRODUCT, IT GETS SELECTED AND WE AUTOFILL ATTRIBUTES, PRODUCT_TYPE/CATEGORY, AND ITS VARIANTS...
SO, OUR SYSTEM WILL SUPPORT "SEARCH OR CREATE"..Search first and only create later. We will be able to reuse the image as well..

2. mutation CreateAttribute {
  attributeCreate(input: {
    name: "Container Type",
    type: PRODUCT_TYPE,
    inputType: DROPDOWN,
    values: [{name: "Bottle"}, {name: "Can"}]
  }) {
    attribute { id }
  }
}

3. mutation CreateProductType {
  productTypeCreate(input: {
    name: "Beverage",
    kind: NORMAL,
    productAttributes: ["QXR0cmlidXRlOjU1"]
  }) {
    productType { id }
  }
}

-------------------------------------------------------------------------------------------------
// With search or create... we ensure our product creation never FAILS coz we reuse EXISTING categoryId and productTypeId.

4. mutation CreateProduct {
  productCreate(input: {
    name: "Premium Soda",
    productType: "UHJvZHVjdFR5cGU6NDI=",
    category: "Q2F0ZWdvcnk6MQ=="
  }) {
    product { id }
  }
}

5. mutation PublishProduct {
  productChannelListingUpdate(
    id: "UHJvZHVjdDoxNzc=",
    input: {
      updateChannels: [{
        channelId: "Q2hhbm5lbDoz",
        isPublished: true,
        visibleInListings: true,
        isAvailableForPurchase: true,
        publishedAt: "2024-03-28T00:00:00Z" # PARSE DATE IN THIS FORMAT.
      }]
    }
  ) {
    product { id }
  }
}

6. # This never ran!! returns "productVariant": null
mutation CreateVariantPrice {
  productVariantCreate(input: {
    product: "UHJvZHVjdDoxNzc=",
    sku: "SODA-001",
    # notice your version was nesting ["Bottle"] badly
    attributes: [{
      id: "QXR0cmlidXRlOjU1", 
      values: ["Bottle"],#Bottle exists!
    }]
    stocks: [{
      warehouse: "V2FyZWhvdXNlOjVhZmVlYWJjLWNjODMtNDUzNy1hY2IyLWRkNDRhNjJjOTc2Mg==",
      quantity: 100
    }]
  }) {
    productVariant { id }
  }
}

# This one ran and retuned the id as UHJvZHVjdFZhcmlhbnQ6NDA1
mutation SetVariantPrice {
  productVariantChannelListingUpdate(
    id: "UHJvZHVjdFZhcmlhbnQ6NDA1",
    input: [{channelId: "Q2hhbm5lbDoz", price: "350.00"}]
  ) {
    variant { id }
  }
}

############################################################################################################
## THIS IS HOW WE QUERY PRODUCTS... FIRST QUERY ALL CATEGORIES THEN MAP TO RENDER THEM IN THIS MANNER.
############################################################################################################

query GetProductsByCategory {
  category(id: "Q2F0ZWdvcnk6MQ==") {  # This was the category ID used in your creation
    name
    products(channel: "Q2hhbm5lbDoz", last: 2) {
      edges {
        node {
          ...ProductBasic # A fragment DEFINED ELSEWHERE OFC /graphql/fragments/product.graphql..
        }
      }
    }
  }
}


🪨 Saleor Principle to Remember
Creating a warehouse ≠ assigning a product or variant to it.
You must manually define stock per product variant for each warehouse using stocks during productVariantCreate.

That's why earlier your product had no stock until you added:

graphql
Copy
Edit
stocks: [{
  warehouse: "WAREHOUSE_ID",
  quantity: 1110
}]
So yes — we always need to do that to make stock available.



➡️ Your ALCORA WAREHOUSE is not in any shipping zone.
➡️ alcora-admin channel is also not in any shipping zone.
(So hakuna way Saleor can expose stock 😤)

✅ Step 2: Let’s Assign the Warehouse & Channel to a Shipping Zone
Let’s use the empty "Kenya Shipping" zone (looks tailor-made for Alcora!)

[Shipping ZONES IS SOMETHING GOOD TO STUDY IN SALEOR]
Shipping Zones in Saleor define where and how your products can be delivered. Think of them as geographic groupings (like "Kenya", "Europe", or "Nairobi Only") that connect:

Warehouses (where stock is located)

Sales Channels (where customers buy)

Shipping Methods (how goods get delivered)

Without a shipping zone:

🏬 A warehouse's stock isn’t visible

🛒 A channel can't offer products for sale

🚚 You can’t configure shipping or fulfillment

Every product shown in a channel must be:

Assigned to a warehouse

That warehouse must belong to a shipping zone

That shipping zone must also include the same channel

This triangle (Warehouse → Shipping Zone → Channel) unlocks stock visibility, delivery options, and checkout success.

In essence, Shipping Zones are the glue between your logistics (warehouses) and your sales front (channels). Properly wiring them is mandatory for Saleor to work as a commerce engine.

👉 Bonus: You can define shipping methods per zone, enabling region-specific delivery fees and speeds (e.g., 1-day delivery in Nairobi, 5-day for Mombasa).

It’s a bit hidden — but it’s the heartbeat of fulfillment in Saleor.





=================================
mutation AttrCreate{
  attributeCreate(input: {
    name: "Alcohol %",
    type: PRODUCT_TYPE,
    inputType: DROPDOWN
  }) {
    attribute { id }
    errors { message }
  }
}

mutation X2{
  attributeCreate(input: {
    name: "Volume (ml)",
    type: PRODUCT_TYPE,
    inputType: NUMERIC
  }) {
    attribute { id }
    errors { message }
  }
}

1&2: QXR0cmlidXRlOjU4, QXR0cmlidXRlOjU5

PRODUCT TYPE:
mutation {
  productTypeCreate(input: {
    name: "Beer",
    kind: NORMAL,
    productAttributes: [
      "QXR0cmlidXRlOjU4",  # Alcohol %
      "QXR0cmlidXRlOjU5"   # Volume (ml)
    ]
  }) {
    productType { id }
    errors { message }
  }
}

// UHJvZHVjdFR5cGU6NDk=

mutation {
  productCreate(input: {
    name: "Tusker Lager",
    productType: "UHJvZHVjdFR5cGU6NDk=",
    category: "Q2F0ZWdvcnk6NDU="
  }) {
    product { id }
    errors { message }
  }
} >> UHJvZHVjdDo0MTE=

----------------------------
mutation {
  productChannelListingUpdate(
    id: "UHJvZHVjdDo0MTE=",
    input: {
      updateChannels: [{
        channelId: "Q2hhbm5lbDo3",
        isPublished: true,
        visibleInListings: true,
        isAvailableForPurchase: true,
        publishedAt: "2025-04-22T00:00:00Z"
      }]
    }
  ) {
    product { id }
    errors { message }
  }
} >>> UHJvZHVjdDo0MTE=

mutation {
  shippingZoneUpdate(
    id: "U2hpcHBpbmdab25lOjg=", # Kenya Shipping
    input: {
      addWarehouses: ["V2FyZWhvdXNlOjVkNmVjYjMzLWJhZGItNGUxMC05MTA2LWNiN2Y0NTRiYjFlYw=="], # Alcora Warehouse
      addChannels: ["Q2hhbm5lbDo3"] # AlcoraAdmin Channel
    }
  ) {
    shippingZone {
      id
      name
      warehouses {
        name
      }
      channels {
        name
      }
    }
    errors {
      field
      message
    }
  }
}
